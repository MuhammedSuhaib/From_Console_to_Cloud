---
name: "fastapi-external-jwt-verification"
description: "Expert skill for implementing JWT-based authentication verification in FastAPI applications with external auth providers like Better Auth. Handles token verification via database lookup, user authentication, protected routes, and user isolation based on external JWT tokens. Includes setup for database integration, token validation, and security best practices. Use when implementing JWT token verification in FastAPI backend that works with external auth services, securing API endpoints with external JWT tokens, or implementing user data isolation with database-verified tokens."
---

# FastAPI External JWT Verification Skill

## When to Use This Skill

- User wants to implement JWT verification in FastAPI with external auth providers (Better Auth, Auth.js, etc.)
- Need to verify JWT tokens generated by frontend/auth service rather than generating in the same app
- Want to implement user isolation with database-verified tokens
- Looking for user-specific data access with external token validation
- Need to set up session database lookup for token validation

## How This Skill Works (Step-by-Step Execution)

1. **Dependency Installation**
   - Install `pyjwt`, `sqlmodel`, and other required packages for token verification
   - Set up environment variables for shared secrets with external auth provider

2. **Database Connection Setup**
   - Configure database connection for session/token lookup
   - Set up session table structure matching external auth provider
   - Implement database session management

3. **Token Verification via Database Lookup**
   - Create middleware to verify JWT tokens by querying session table
   - Extract user ID from verified session records
   - Implement proper error handling for invalid/expired tokens

4. **Protected Routes with User Isolation**
   - Create dependency injection for user authentication
   - Implement user-specific data filtering
   - Add protected route examples that verify user ID matches request

5. **Security Implementation**
   - Add proper error handling for authentication failures
   - Implement user isolation and data access controls
   - Configure security headers and rate limiting

## Output You Will Receive

After activation, I will deliver:

- Complete dependency installation commands
- Database session setup for token verification
- JWT token verification functions using database lookup
- User authentication dependency with proper validation
- Protected route examples with user isolation
- Security best practices and configurations

## Example Usage

**User says:**
"I have Better Auth on frontend and need my FastAPI backend to verify the JWT tokens."

**This Skill Instantly Activates → Delivers:**

- JWT verification function that queries Better Auth session table
- Database configuration for session token validation
- User authentication dependency that extracts user ID from verified tokens
- Protected route examples with user data isolation
- Complete setup for secure frontend-backend communication

**User says:**
"Verify external JWT tokens in my FastAPI backend."

**This Skill Responds:**
→ Sets up database lookup for token validation
→ Creates token verification middleware
→ Implements user isolation from JWT claims
→ Provides security best practices

## Activate This Skill By Saying

- "Verify external JWT tokens in my FastAPI app"
- "Secure my backend with Better Auth JWT verification"
- "Implement user isolation with database-verified tokens"
- "I need JWT validation from external auth provider"

## Core Implementation Steps

### 1. Install Dependencies
```bash
pip install pyjwt python-jose[cryptography] sqlmodel
```

### 2. JWT Token Verification (Database Lookup Approach)
```python
import logging
from fastapi import Depends, HTTPException
from fastapi.security import HTTPBearer
from sqlmodel import Session
from database import get_session
import sqlalchemy
from datetime import datetime, timezone

logger = logging.getLogger(__name__)

security = HTTPBearer()

def get_current_user_id(
    creds = Depends(security),
    session: Session = Depends(get_session)
) -> str:
    token = creds.credentials

    try:
        # Query the session table directly - external auth providers like Better Auth store tokens in the database
        # userId and expiresAt are standard columns for many auth providers
        query = sqlalchemy.text('SELECT "userId", "expiresAt" FROM "session" WHERE "token" = :t')
        result = session.execute(query, {"t": token}).fetchone()

        if not result:
            logger.warning(f"Invalid session token attempted: {token[:10]}...")
            raise HTTPException(status_code=401, detail="Invalid session")

        user_id, expires_at = result

        # Check if session has expired
        # Ensure timezone comparison is consistent
        if expires_at.replace(tzinfo=timezone.utc) < datetime.now(timezone.utc):
            logger.warning(f"Session expired for user: {user_id}")
            raise HTTPException(status_code=401, detail="Session expired")

        logger.info(f"User {user_id} authenticated successfully")
        return str(user_id)

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Auth System Error: {str(e)}")
        raise HTTPException(status_code=401, detail="Internal authentication failure")
```

### 3. Protected Routes with User Isolation
```python
from fastapi import APIRouter, Depends, HTTPException
from sqlmodel import Session, select
from models import Task
from auth.jwt import get_current_user_id
from database import get_session

router = APIRouter(prefix="/api", tags=["tasks"])

@router.get("/tasks")
def list_tasks(
    session: Session = Depends(get_session),
    user_id: str = Depends(get_current_user_id),  # User ID from external auth token verification
):
    # Only return tasks belonging to the authenticated user
    tasks = session.exec(
        select(Task).where(Task.user_id == user_id)
    ).all()
    return {"data": tasks}

@router.post("/tasks")
def create_task(
    task: TaskCreate,
    session: Session = Depends(get_session),
    user_id: str = Depends(get_current_user_id),  # User ID from external auth token verification
):
    # Assign task to authenticated user ID from external auth provider
    db_task = Task(**task.dict(), user_id=user_id)
    session.add(db_task)
    session.commit()
    session.refresh(db_task)
    return {"data": db_task}

@router.put("/tasks/{task_id}")
def update_task(
    task_id: int,
    updates: TaskUpdate,
    session: Session = Depends(get_session),
    user_id: str = Depends(get_current_user_id),  # User ID from external auth token verification
):
    # Verify that the user owns this task
    task = session.get(Task, task_id)
    if not task or task.user_id != user_id:
        raise HTTPException(status_code=404)

    for k, v in updates.dict(exclude_unset=True).items():
        setattr(task, k, v)

    task.updated_at = datetime.utcnow()
    session.commit()
    session.refresh(task)
    return {"data": task}
```

### 4. Environment Configuration
```
DATABASE_URL=postgresql://user:password@host:port/database
BETTER_AUTH_SECRET=your_shared_secret
NEXT_PUBLIC_BETTER_AUTH_URL=http://localhost:8000
```

### 5. Security Best Practices
- User ID validation to ensure users can only access their own data
- Proper error handling for authentication failures
- Rate limiting to prevent abuse
- Secure token storage and transmission
- Clean separation between authentication and business logic